#########################
#### Training
#### Fold: 1 | Image Size: (224, 313) | Model: tf_efficientnet_b1_ns | Batch Size: 128 | Scheduler: cos
#### Num Train: 78,407 | Num Valid: 3,216
100%|██████████| 1/1 [00:05<00:00,  5.22s/it]









100%|██████████| 26/26 [00:52<00:00,  2.00s/it]
Epoch: 1 | Train Loss: 6.374211311340332 | Val Loss: 1564.4835158128005 | Val Padded_cmAP : 0.446139821428876
100%|██████████| 1/1 [00:02<00:00,  2.46s/it]







 92%|█████████▏| 24/26 [00:19<00:05,  2.63s/it]
Epoch: 2 | Train Loss: 6.334932327270508 | Val Loss: 319.6454591017503 | Val Padded_cmAP : 0.5049190630247589
# Loading best model
100%|██████████| 26/26 [00:45<00:00,  1.75s/it]







100%|██████████| 26/26 [00:45<00:00,  1.74s/it]
/opt/conda/lib/python3.7/site-packages/pandas/core/frame.py:3678: PerformanceWarning: DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
  self[col] = igetitem(value, i)
>>> FOLD 1 Padded_cmAP = 0.505
# WandB
/opt/conda/lib/python3.7/site-packages/pandas/core/indexing.py:1667: SettingWithCopyWarning:
A value is trying to be set on a copy of a slice from a DataFrame.
Try using .loc[row_indexer,col_indexer] = value instead
See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy
  self.obj[key] = value